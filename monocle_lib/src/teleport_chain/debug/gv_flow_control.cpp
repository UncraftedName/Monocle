#include "gv_flow_control.hpp"

#include <format>

namespace mon {

void GraphvizFlowControlResult::Clear()
{
    all_queued_vals.clear();
    teleports.clear();
    call_queueds.clear();
    state = chain_state{};
    tp_exceeded_node.exists = false;
}

void GraphvizFlowControlResult::QueueFunc(TeleportChainInternalState::queue_entry fn)
{
    all_queued_vals.push_back(fn);
}

void GraphvizFlowControlResult::DequeueFunc()
{
    state.cur_queue_start++;
    MON_ASSERT(state.cur_queue_start <= all_queued_vals.size());
}

void GraphvizFlowControlResult::TpExceeded(bool last_tp_blue)
{
    MON_ASSERT(!tp_exceeded_node.exists && !state.in_teleport_fn);
    tp_exceeded_node.blue = last_tp_blue;
    tp_exceeded_node.call_queued_parent_index = state.cur_fn_index;
    tp_exceeded_node.exists = true;
}

void GraphvizFlowControlResult::PostTeleportTransform(bool blue, PlaneSide plane_side)
{
    if (teleports.empty())
        state.blue_primary = blue;
    state.cur_cum_tp += blue == state.blue_primary ? 1 : -1;
    teleport_func fn{
        .call_queued_parent_index = state.cur_fn_index,
        .blue = blue,
        .plane_side = plane_side,
        .cum_tp = state.cur_cum_tp,
    };
    state.last_teleport_port = 0;
    state.cur_fn_index = teleports.size();
    state.in_teleport_fn = true;
    teleports.push_back(fn);
}

void GraphvizFlowControlResult::CallQueuedPostAddNull()
{
    call_queued_func fn{
        .teleport_parent_index = state.cur_fn_index,
        .port = state.last_teleport_port,
        .chunk = queue_chunk{state.cur_queue_start, all_queued_vals.size()},
    };
    state.cur_fn_index = call_queueds.size();
    state.in_teleport_fn = false;
    call_queueds.push_back(fn);
}

void GraphvizFlowControlResult::FuncLeave()
{
    if (state.in_teleport_fn) {
        state.cur_fn_index = teleports[state.cur_fn_index].call_queued_parent_index;
    } else {
        state.last_teleport_port = call_queueds[state.cur_fn_index].port + 1;
        state.cur_fn_index = call_queueds[state.cur_fn_index].teleport_parent_index;
    }
    state.in_teleport_fn ^= true;
}

std::ostream& operator<<(std::ostream& os, GraphvizFlowControlResult const& res)
{
    std::string_view indent_str = "    ";

    std::string cur_indent;
    auto add_indent = [&]() { cur_indent += indent_str; };
    auto sub_indent = [&]() { cur_indent.erase(cur_indent.end() - indent_str.size(), cur_indent.end()); };
    auto close_scope = [&]() {
        sub_indent();
        os << cur_indent << "};\n";
    };

    auto portal_col = [](bool blue) { return blue ? "cornflowerblue" : "orange"; };

    std::string_view default_edge_attribs = "style = dotted";
    std::string_view queued_teleport_edge_attribs = "style = solid; color = red";

    os << cur_indent << "/* Generated by monocle */\n";
    os << cur_indent << "strict graph G {\n";
    add_indent();

    os << cur_indent << "graph [label = \"\"];\n";
    os << cur_indent << "node [shape = oval] {\n";
    add_indent();

    auto queue_fn_to_char = [](TeleportChainInternalState::queue_entry v) {
        switch (v) {
            case TeleportChainInternalState::FUNC_TP_BLUE:
                return 'B';
            case TeleportChainInternalState::FUNC_TP_ORANGE:
                return 'O';
            default:
                return 'N';
        }
    };

    // write out call queued nodes

    for (size_t i = 0; i < res.call_queueds.size(); i++) {
        auto& cq = res.call_queueds[i];
        os << cur_indent << "call_queued_" << i << " [label = \"";

        for (size_t j = cq.chunk.start; j < cq.chunk.end; j++)
            os << queue_fn_to_char(res.all_queued_vals[j]);

        os << "\"];\n";
    }

    close_scope(); // node shape scope

    os << cur_indent << "node [shape = plaintext] {\n";
    add_indent();

    // write out teleport nodes

    for (size_t i = 0; i < res.teleports.size(); i++) {
        auto& tp = res.teleports[i];

        using PS = GraphvizFlowControlResult::PlaneSide;

        os << cur_indent << "teleport_" << i << " [color = " << portal_col(tp.blue) << "; "
           << "label = <<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPANDING=\"0\">"
           << "<TR><TD colspan=\"4\">" << tp.cum_tp
           << (tp.plane_side == PS::InFront ? "F" : (tp.plane_side == PS::Behind ? "B" : "")) << "</TD></TR>"
           << "<TR><TD PORT=\"0\">E</TD>"
           << "<TD PORT=\"1\" BGCOLOR=\"" << portal_col(!tp.blue) << "\">P</TD>"
           << "<TD PORT=\"2\" BGCOLOR=\"" << portal_col(!tp.blue) << "\">P</TD>"
           << "<TD PORT=\"3\">E</TD>"
           << "</TR></TABLE>>];\n";
    }

    close_scope(); // node shape scope

    // first touch node

    os << cur_indent << "first [label = \"first portal touch\"; color = " << portal_col(res.state.blue_primary)
       << "; shape = box];\n";

    // tp exceeded node

    if (res.tp_exceeded_node.exists) {
        os << cur_indent << "tp_exceeded [color = " << portal_col(res.tp_exceeded_node.blue)
           << "; label = \"max number of teleports exceeded\"; shape = tripleoctagon];\n";
    }

    os << cur_indent << "edge [" << default_edge_attribs << "] {\n";
    add_indent();

    if (res.tp_exceeded_node.exists) {
        os << cur_indent << "call_queued_" << res.tp_exceeded_node.call_queued_parent_index << "-- tp_exceeded;\n";
    }

    // connect edges

    for (size_t i = 0; i < res.call_queueds.size(); i++) {
        auto& cq = res.call_queueds[i];
        if (i == 0)
            os << cur_indent << "first";
        else
            os << cur_indent << "teleport_" << cq.teleport_parent_index << ":" << cq.port;
        os << " -- call_queued_" << i;
        MON_ASSERT(cq.chunk.end - cq.chunk.start >= 2);
        if (res.all_queued_vals[cq.chunk.end - 1] < 0 &&
            (res.all_queued_vals[cq.chunk.end - 2] == TeleportChainInternalState::FUNC_TP_BLUE ||
             res.all_queued_vals[cq.chunk.end - 2] == TeleportChainInternalState::FUNC_TP_ORANGE)) {
            // end of queue is '...ON' or '...BN' means that a teleport was queued
            os << " [" << queued_teleport_edge_attribs << "];\n";
        } else {
            os << ";\n";
        }
    }

    for (size_t i = 0; i < res.teleports.size(); i++) {
        auto& tp = res.teleports[i];
        os << cur_indent << "call_queued_" << tp.call_queued_parent_index << " -- teleport_" << i << ";\n";
    }

    close_scope(); // edge style scope

    // node legend

    os << cur_indent << "subgraph cluster_01 {\n";
    add_indent();

    os << cur_indent << "label = \"Node Legend\";\n";
    os << cur_indent << "legend_n1 [label = \"CallQueued()\\nwith queue view\"; shape = oval];\n";

    os << cur_indent << "legend_n2 [label=<"
       << "<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPANDING=\"0\">"
       << "<TR><TD>Immediately after<BR/>portal transform<BR/>by blue portal</TD></TR>"
       << "<TR><TD>"
       << "<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPANDING=\"0\">"
       << "<TR><TD colspan=\"4\">" << "'0B'=-1 CUM Teleports,<BR/>Behind Portal</TD></TR>"
       << "<TR><TD>E</TD>"
       << "<TD BGCOLOR=\"" << portal_col(false) << "\">P</TD>"
       << "<TD BGCOLOR=\"" << portal_col(false) << "\">P</TD>"
       << "<TD>E</TD>"
       << "</TR></TABLE>"
       << "</TD></TR>"
       << "</TABLE>"
       << ">; color = " << portal_col(true) << "; shape = plaintext];\n";

    close_scope(); // subgraph scope

    // edge legend

    os << cur_indent << "subgraph cluster_02 {\n";
    add_indent();
    os << cur_indent << "label = \"Edge Legend\";\n";
    os << cur_indent << "node [shape = point]; {\n";
    add_indent();
    os << cur_indent << "legend_e1 -- legend_e2 [label = \"nested call where\\nShouldTeleport() was true\"; "
       << queued_teleport_edge_attribs << "];\n";
    os << cur_indent << "legend_e3 -- legend_e4 [label = \"nested call\"; " << default_edge_attribs << "];\n";
    close_scope(); // node shape scope
    close_scope(); // subgraph scope

    // align legends
    os << cur_indent << "legend_n2 -- legend_e3 [style = invis];\n";

    close_scope(); // graph scope
    return os;
}

} // namespace mon