#include "vag_logic.hpp"

#include <format>

template <class... Args>
static void FormatIndentedLine(DotGen& dg, std::format_string<Args...> fmt, Args&&... args)
{
    dg.buf += dg.style.indent;
    std::format_to(std::back_inserter(dg.buf), fmt, std::forward<Args>(args)...);
    dg.buf += '\n';
}

struct tp_queue_view {
    const TeleportChain::queue_type& queue;
};

template <typename Char>
struct std::formatter<tp_queue_view, Char> {

    constexpr auto parse(std::basic_format_parse_context<Char>& ctx)
    {
        return ctx.begin();
    }

    static Char QueueElemToChar(TeleportChain::queue_entry qe)
    {
        switch (qe) {
            case TeleportChain::FUNC_TP_BLUE:
                return Char('B');
            case TeleportChain::FUNC_TP_ORANGE:
                return Char('O');
            case TeleportChain::FUNC_RECHECK_COLLISION:
                return Char('R');
            default:
                return Char('N');
        }
    }

    template <typename FormatContext>
    auto format(const tp_queue_view& v, FormatContext& ctx) const
    {
        auto out = ctx.out();
        for (auto qe : v.queue)
            *out++ = QueueElemToChar(qe);
        return out;
    }
};

void DotGen::PushRootNode(bool blue)
{
    nodeStack.clear();
    buf.clear();
    nodeCounter = 0;

    buf +=
        "/* Generated by Monocle */\n"
        "strict graph G {\n";
    FormatIndentedLine(*this, "graph [label = \"\"];");
    FormatIndentedLine(*this, "node [shape = record];");
    FormatIndentedLine(*this,
                       "\"{}\" [color = {}; label = P; shape = circle];",
                       nodeStack.emplace_back(nodeCounter++),
                       blue ? style.blueCol : style.orangeCol);
}

void DotGen::PushCallQueuedNode(bool queued_teleport, const TeleportChain::queue_type& queue, int from_touch_call_idx)
{
    int lastNode = nodeStack.back();
    int newNode = nodeStack.emplace_back(nodeCounter++);
    FormatIndentedLine(*this, "\"{}\" [label = \"{}\"];", newNode, tp_queue_view{queue});
    FormatIndentedLine(*this,
                       "\"{}\":\"{}\" -- \"{}\" [{}];",
                       lastNode,
                       from_touch_call_idx,
                       newNode,
                       queued_teleport ? style.teleportEdgeAttributes : style.defaultEdgeAttributes);
}

void DotGen::PushTeleportNode(bool blue, int cum_teleports, VecUlpDiff ulpDiff)
{
    int lastNode = nodeStack.back();
    int newNode = nodeStack.emplace_back(nodeCounter++);
    FormatIndentedLine(*this,
                       "\"{}\" [label = <"
                       "<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"0\">"
                       "<TR><TD colspan=\"4\">{}{}</TD></TR>"
                       "<TR>"
                       "<TD PORT=\"0\">E</TD>"
                       "<TD PORT=\"1\" BGCOLOR=\"{}\">P</TD>"
                       "<TD PORT=\"2\" BGCOLOR=\"{}\">P</TD>"
                       "<TD PORT=\"3\">E</TD>"
                       "</TR>"
                       "</TABLE>"
                       ">; shape = plaintext; color = {}];",
                       newNode,
                       cum_teleports,
                       ulpDiff.Valid() ? (ulpDiff.PtWasBehindPlane() ? "B" : "F") : "",
                       blue ? style.orangeCol : style.blueCol,
                       blue ? style.orangeCol : style.blueCol,
                       blue ? style.blueCol : style.orangeCol);
    FormatIndentedLine(*this, "\"{}\" -- \"{}\" [{}];", lastNode, newNode, style.defaultEdgeAttributes);
}

void DotGen::PushExceededTpNode(bool blue)
{
    int lastNode = nodeStack.back();
    int newNode = nodeStack.emplace_back(nodeCounter++);
    FormatIndentedLine(*this,
                       "\"{}\" [label = \"max number of teleports exceeded\"; color = {}; shape = tripleoctagon]",
                       newNode,
                       blue ? style.blueCol : style.orangeCol);
    FormatIndentedLine(*this, "\"{}\" -- \"{}\" [{}];", lastNode, newNode, style.defaultEdgeAttributes);
}
