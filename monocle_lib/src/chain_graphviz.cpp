#include "vag_logic.hpp"

#include <format>

namespace mon {

template <class... Args>
static void FormatIndentedLine(GraphvizGen& dg, std::format_string<Args...> fmt, Args&&... args)
{
    dg.buf += dg.style.indent;
    std::format_to(std::back_inserter(dg.buf), fmt, std::forward<Args>(args)...);
    dg.buf += '\n';
}

struct tp_queue_view {
    const TeleportChainInternalState::queue_type& queue;
};

template <typename Char>
struct std::formatter<tp_queue_view, Char> {

    using INTERN = mon::TeleportChainInternalState;

    constexpr auto parse(std::basic_format_parse_context<Char>& ctx)
    {
        return ctx.begin();
    }

    static Char QueueElemToChar(INTERN::queue_entry qe)
    {
        switch (qe) {
            case INTERN::FUNC_TP_BLUE:
                return Char('B');
            case INTERN::FUNC_TP_ORANGE:
                return Char('O');
            case INTERN::FUNC_RECHECK_COLLISION:
                return Char('R');
            default:
                MON_ASSERT(qe < 0);
                return Char('N');
        }
    }

    template <typename FormatContext>
    auto format(const mon::tp_queue_view& v, FormatContext& ctx) const
    {
        auto out = ctx.out();
        for (auto qe : v.queue)
            *out++ = QueueElemToChar(qe);
        return out;
    }
};

void GraphvizGen::ResetAndPushRootNode(bool blue)
{
    node_stack.clear();
    buf.clear();
    node_counter = 0;
    touch_call_index = -1;
    last_teleport_call_queued_a_teleport = false;

    buf +=
        "/* Generated by Monocle */\n"
        "strict graph G {\n";
    FormatIndentedLine(*this, "graph [label = \"\"];");
    FormatIndentedLine(*this, "node [shape = record];");
    FormatIndentedLine(*this,
                       "\"{}\" [color = {}; label = P; shape = circle];",
                       node_stack.emplace_back(node_counter++),
                       blue ? style.blueCol : style.orangeCol);
}

void GraphvizGen::PushCallQueuedNode(const TeleportChainInternalState::queue_type& queue)
{
    int lastNode = node_stack.back();
    int newNode = node_stack.emplace_back(node_counter++);
    FormatIndentedLine(*this, "\"{}\" [label = \"{}\"];", newNode, tp_queue_view{queue});
    FormatIndentedLine(
        *this,
        "\"{}\":\"{}\" -- \"{}\" [{}];",
        lastNode,
        touch_call_index,
        newNode,
        last_teleport_call_queued_a_teleport ? style.teleportEdgeAttributes : style.defaultEdgeAttributes);
}

void GraphvizGen::PushTeleportNode(bool blue, int cum_teleports, int planeSide)
{
    int lastNode = node_stack.back();
    int newNode = node_stack.emplace_back(node_counter++);
    FormatIndentedLine(*this,
                       "\"{}\" [label = <"
                       "<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"0\">"
                       "<TR><TD colspan=\"4\">{}{}</TD></TR>"
                       "<TR>"
                       "<TD PORT=\"0\">E</TD>"
                       "<TD PORT=\"1\" BGCOLOR=\"{}\">P</TD>"
                       "<TD PORT=\"2\" BGCOLOR=\"{}\">P</TD>"
                       "<TD PORT=\"3\">E</TD>"
                       "</TR>"
                       "</TABLE>"
                       ">; shape = plaintext; color = {}];",
                       newNode,
                       cum_teleports,
                       std::abs(planeSide) == 1 ? (planeSide == -1 ? "B" : "F") : "",
                       blue ? style.orangeCol : style.blueCol,
                       blue ? style.orangeCol : style.blueCol,
                       blue ? style.blueCol : style.orangeCol);
    FormatIndentedLine(*this, "\"{}\" -- \"{}\" [{}];", lastNode, newNode, style.defaultEdgeAttributes);
}

void GraphvizGen::PushExceededTpNode(bool blue)
{
    int lastNode = node_stack.back();
    int newNode = node_stack.emplace_back(node_counter++);
    FormatIndentedLine(*this,
                       "\"{}\" [label = \"max number of teleports exceeded\"; color = {}; shape = tripleoctagon]",
                       newNode,
                       blue ? style.blueCol : style.orangeCol);
    FormatIndentedLine(*this, "\"{}\" -- \"{}\" [{}];", lastNode, newNode, style.defaultEdgeAttributes);
}

} // namespace mon
